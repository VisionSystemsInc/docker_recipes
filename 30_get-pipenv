#!/usr/bin/env sh

# This script should not be sourced, but called, or else bad things could happen.

#*# docker/recipes/get-pipenv

#**
# .. default-domain:: bash
#
# .. _get_pipenv:
#
# ==========
# Get Pipenv
# ==========
#
# .. file:: get_pipenv
#
# Functions to help install pipenv with only python installed and no elevated privileges, no ``pip`` or ``sudo`` required
#
# .. function:: install_pipenv
#
# Install pipenv into a virtualenv. Does not need to have pip already installed and does not use privileged permissions. Makes use of the virtualenv zipapp, as per https://virtualenv.pypa.io/en/latest/installation.html#via-zipapp
#
# :Arguments: [``$1``] - The location of the virtualenv, defaults to ``${PIPENV_VIRTUALENV-${HOME}/pipenv}``
# :Parameters: * ``PIPENV_PYTHON`` - Optionally specify which python you want to use. Default is to favor python3, trying ``python3``, ``python``, then finally falling back to ``python2``.
#              * ``PIPENV_VERSION`` - The version of pipenv to install, defaults - ``2018.11.26``
#              * ``VIRTUALENV_PYZ`` - Name of downloaded ``virtualenv.pyz``, else it will attempt to download it itself.
#**
install_pipenv()
{
  # python executable
  : ${PIPENV_PYTHON:="$( (command -v python3 || command -v python || command -v python2) | head -n 1)"}
  [ -n "${PIPENV_PYTHON}" ] # Make sure python was found

  # setup
  local output_dir="${1-${PIPENV_VIRTUALENV-${HOME}/pipenv}}"
  local pipenv_ver="${PIPENV_VERSION:-2018.11.26}"
  local virtualenv_pyz=${VIRTUALENV_PYZ-}

  # use existing virtualenv
  virtualenv_ver="$("${PIPENV_PYTHON}" -m virtualenv --version 2>/dev/null || :)"
  if [ -n "${virtualenv_ver}" ]; then
    echo "Found virtualenv (${virtualenv_ver})"
    "${PIPENV_PYTHON}" -m virtualenv "${output_dir}"

  # use virtualenv zipapp
  # https://virtualenv.pypa.io/en/latest/installation.html#via-zipapp
  else
    echo "Using virtualenv zipapp"

    # temporary directory
    local tmp_dir="$(mktemp -d)"

    # download virtualenv_pyz
    if [ ! -r "${virtualenv_pyz}" ]; then
      virtualenv_pyz="${tmp_dir}/virtualenv.pyz"

      "${PIPENV_PYTHON}" -c "if True:
          import sys, traceback
          virtualenv_pyz = sys.argv[1]
          ver = sys.version_info
          url = ('https://bootstrap.pypa.io/virtualenv/{}.{}/virtualenv.pyz'
                .format(ver[0],ver[1]))

          try:
            import requests
            content = requests.get(url).content
          except:
            try:
              from urllib2 import urlopen
            except:
              from urllib.request import urlopen
            content = urlopen(url).read()

          with open(virtualenv_pyz, 'wb') as fid:
            fid.write(content)
          " "${virtualenv_pyz}"
    fi

    # create output virtualenv
    "${PIPENV_PYTHON}" "${virtualenv_pyz}" "${output_dir}"

    # cleanup
    rm -rf "${tmp_dir}"
  fi

  # add pipenv to output virtualenv
  local output_pip
  if [ "${OS-}" = "Windows_NT" ]; then
    output_pip="${output_dir}/Scripts/pip"
  else
    output_pip="${output_dir}/bin/pip"
  fi
  "${output_pip}" install --no-cache-dir pipenv=="${pipenv_ver}"
}

#**
# .. function:: setup_container_pipenv
#
# Sets up some additional behavior, useful in a container. Creates a symlink in the path to ``pipenv`` and adds a ``fake_package`` script to the bin directory for faking out local packages in pipenv during container build stages.
#
# :Arguments: * [``$1``] - The location of the virtualenv, defaults to ``${HOME}/pipenv``
#             * [``$2``] - The location of the symlink for pipenv, defaults to ``/usr/local/bin/pipenv``
#**
setup_container_pipenv()
{
  ln -s "${1-${PIPENV_VIRTUALENV-${HOME}/pipenv}}/bin/pipenv" "${2-/usr/local/bin/pipenv}"

  cat - > "${1-${PIPENV_VIRTUALENV-${HOME}/pipenv}}/bin/fake_package" << "EOF"
#!/usr/bin/env sh

set -eu

# Useful for creating a fake editable package for when you plan on mounting it
# in at runtime
# $1 - name
# $2 - subdir

mkdir -p "${2-${1}}"
touch "${2-${1}}/init.py"
if [ ! -e "setup.py" ]; then
  echo "from distutils.core import setup" > setup.py
  echo "setup(name='${1}', packages=['${2-${1}}'], description='Project')" >> setup.py
fi
EOF
  chmod 755 "${1-${PIPENV_VIRTUALENV-${HOME}/pipenv}}/bin/fake_package"
}

if [ -n "${BASH_SOURCE+set}" ]; then
  if [ "${BASH_SOURCE[0]}" = "${0}" ] || [ "$(basename "${BASH_SOURCE[0]}")" = "${0}" ]; then
    set -eu
    install_pipenv ${@+"${@}"}
    setup_container_pipenv ${@+"${@}"}
    # Self delete this file, so that pipenv doesn't try to get installed twice if
    # /usr/local/share/just/container_build_patch/* is called twice
    exec bash -c "rm '${BASH_SOURCE[0]}'"
  fi
else
  case "${0}" in
    *30_get-pipenv) # Ran
      set -eu
      install_pipenv ${@+"${@}"}
      setup_container_pipenv ${@+"${@}"}
      # sh doesn't have BASH_SOURCE or exact equivalent, this is closest, unless
      # they are sourcing it, then bad things can happen, hence the guards
      exec bash -c "rm '${0}'"
      ;;
    *sh) # Sourced for sh/dash/etc...
      ;;
  esac
fi
