#!/usr/bin/env bash

# This script should not be sourced, but called, or else bad things could happen.

#*# docker/recipes/get-pipenv

# Temp fix for https://github.com/pypa/virtualenv/issues/1949
if [ -f "${VSI_COMMON_DIR-}/linux/real_path" ]; then
  source "${VSI_COMMON_DIR}/linux/real_path"
else
  if command -v realpath > /dev/null 2>&1; then
    function real_path()
    {
      realpath ${@+"${@}"}
    }
  elif readlink -f / > /dev/null 2>&1; then
    function real_path()
    {
      readlink -f ${@+"${@}"}
    }
  else
    function real_path()
    {
      for x in "${@}"; do
        real_path_manual "${x}"
      done
    }
  fi

  function real_path_manual()
  {
    pushd "$(dirname "${1}")" &> /dev/null
      local target="$(basename "${1}")"

      while [ -L "$target" ]
      do
        target="$(readlink "$target")"
        cd "$(dirname "${target}")"
        target="$(basename "${target}")"
      done

      local physical_dir="$(pwd -P)"

      if [ "${target}" = "." ]; then
        target=""
      else
        target="/${target}"
      fi
    popd &> /dev/null

    if [ "${physical_dir}" = "/" ]; then
      if [ "${target}" = "//" ] || [ "${target}" = "" ]; then
        echo /
      else
        echo "$target"
      fi
    else
      echo "${physical_dir}$target"
    fi
  }
fi


#**
# .. function:: download_to_stdout
#
# Download a file from the internet and output stream to stdout.  Adapted from ``${VSI_COMMON_DIR}/linux/web_tools.bsh```
#
# :Arguments: ``$1`` - URL to download
# :Output: ``stdout`` - Binary stream of the url
#
# Tries to download a file via various methods, in order:
#
# 1. ``wget`` using ``wget -qO -``
# 2. ``curl`` using ``curl -fsSL``
# 3. ``${PIPENV_PYTHON}`` using the ``requests``, ```urllib2``, or ``urllib`` library
#**
function download_to_stdout()
{
  local success=1
  if command -v wget &> /dev/null; then
    wget "${1}" -qO - && success=0 || success=$?
  fi
  if [ "${success}" != "0" ] && command -v curl &> /dev/null; then
    curl -fsSL "${1}" && success=0 || success=$?
  fi
  if [ "${success}" != "0" ]; then
    "${PIPENV_PYTHON}" -c 'if True:
        try:
          import requests
          os.write(1, requests.get("'"${1}"'").content)
        except:
          try:
            import urllib2 as u
          except:
            import urllib.request as u
          import os
          os.write(1,u.urlopen("'"${1}"'").read())
        ' && success=0 || success=$?
  fi
  if [ "${success}" != "0" ]; then
    echo "Cannot download a file" >&2
    return 2
  fi
}


#**
# .. default-domain:: bash
#
# .. _get_pipenv:
#
# ==========
# Get Pipenv
# ==========
#
# .. file:: get_pipenv
#
# Functions to help install pipenv with only python installed and no elevated privileges, no ``pip`` or ``sudo`` required
#
# .. function:: install_pipenv
#
# Install pipenv into a virtualenv. Does not need to have pip already installed and does not use privileged permissions. Makes use of the virtualenv zipapp, as per https://virtualenv.pypa.io/en/latest/installation.html#via-zipapp
#
# :Arguments: [``$1``] - The location of the virtualenv, defaults to ``${PIPENV_VIRTUALENV-${HOME}/pipenv}``
# :Parameters: * ``PIPENV_PYTHON`` - Optionally specify which python you want to use. Default is to favor python3, trying ``python3``, ``python``, then finally falling back to ``python2``.
#              * ``PIPENV_VERSION`` - The version of pipenv to install, defaults - ``2018.11.26``
#              * ``VIRTUALENV_PYZ`` - Name of downloaded ``virtualenv.pyz``, else it will attempt to download it itself.
#**
install_pipenv()
{
  # python executable
  : ${PIPENV_PYTHON:="$( (command -v python3 || command -v python || command -v python2) | head -n 1)"}
  [ -n "${PIPENV_PYTHON}" ] # Make sure python was found

  # setup
  local output_dir="${1-${PIPENV_VIRTUALENV-${HOME}/pipenv}}"
  local pipenv_ver="${PIPENV_VERSION:-2018.11.26}"
  local virtualenv_pyz=${VIRTUALENV_PYZ-}

  # use existing virtualenv
  virtualenv_ver="$("${PIPENV_PYTHON}" -m virtualenv --version 2>/dev/null || :)"
  if [ -n "${virtualenv_ver}" ]; then
    echo "Found virtualenv (${virtualenv_ver})"
    "${PIPENV_PYTHON}" -m virtualenv "${output_dir}"

  # use virtualenv zipapp
  # https://virtualenv.pypa.io/en/latest/installation.html#via-zipapp
  else
    echo "Using virtualenv zipapp"

    # temporary directory
    local tmp_dir="$(mktemp -d)"

    # download virtualenv_pyz
    if [ ! -r "${virtualenv_pyz}" ]; then

      # source url
      local url="$("${PIPENV_PYTHON}" -c "if True:
          import sys
          ver = sys.version_info
          print('https://bootstrap.pypa.io/virtualenv/{}.{}/virtualenv.pyz'
                .format(ver[0],ver[1]) )
          ")"

      # download to file
      virtualenv_pyz="${tmp_dir}/virtualenv.pyz"
      download_to_stdout "${url}" > "${virtualenv_pyz}"    
    fi

    # Temp fix for https://github.com/pypa/virtualenv/issues/1949
    virtualenv_pyz="$(real_path "${virtualenv_pyz}")"

    # create output virtualenv
    "${PIPENV_PYTHON}" "${virtualenv_pyz}" "${output_dir}"

    # cleanup
    rm -rf "${tmp_dir}"
  fi

  # add pipenv to output virtualenv
  local output_pip
  if [ "${OS-}" = "Windows_NT" ]; then
    output_pip="${output_dir}/Scripts/pip"
  else
    output_pip="${output_dir}/bin/pip"
  fi
  "${output_pip}" install --no-cache-dir pipenv=="${pipenv_ver}"
}

#**
# .. function:: setup_container_pipenv
#
# Sets up some additional behavior, useful in a container. Creates a symlink in the path to ``pipenv`` and adds a ``fake_package`` script to the bin directory for faking out local packages in pipenv during container build stages.
#
# :Arguments: * [``$1``] - The location of the virtualenv, defaults to ``${HOME}/pipenv``
#             * [``$2``] - The location of the symlink for pipenv, defaults to ``/usr/local/bin/pipenv``
#**
setup_container_pipenv()
{
  ln -s "${1-${PIPENV_VIRTUALENV-${HOME}/pipenv}}/bin/pipenv" "${2-/usr/local/bin/pipenv}"

  cat - > "${1-${PIPENV_VIRTUALENV-${HOME}/pipenv}}/bin/fake_package" << "EOF"
#!/usr/bin/env sh

set -eu

# Useful for creating a fake editable package for when you plan on mounting it
# in at runtime
# $1 - name
# $2 - subdir

mkdir -p "${2-${1}}"
touch "${2-${1}}/init.py"
if [ ! -e "setup.py" ]; then
  echo "from distutils.core import setup" > setup.py
  echo "setup(name='${1}', packages=['${2-${1}}'], description='Project')" >> setup.py
fi
EOF
  chmod 755 "${1-${PIPENV_VIRTUALENV-${HOME}/pipenv}}/bin/fake_package"
}

if [ -n "${BASH_SOURCE+set}" ]; then
  if [ "${BASH_SOURCE[0]}" = "${0}" ] || [ "$(basename "${BASH_SOURCE[0]}")" = "${0}" ]; then
    set -eu
    install_pipenv ${@+"${@}"}
    setup_container_pipenv ${@+"${@}"}
    # Self delete this file, so that pipenv doesn't try to get installed twice if
    # /usr/local/share/just/container_build_patch/* is called twice
    exec bash -c "rm '${BASH_SOURCE[0]}'"
  fi
else
  case "${0}" in
    *30_get-pipenv) # Ran
      set -eu
      install_pipenv ${@+"${@}"}
      setup_container_pipenv ${@+"${@}"}
      # sh doesn't have BASH_SOURCE or exact equivalent, this is closest, unless
      # they are sourcing it, then bad things can happen, hence the guards
      exec bash -c "rm '${0}'"
      ;;
    *sh) # Sourced for sh/dash/etc...
      ;;
  esac
fi
